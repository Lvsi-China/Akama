---
layout:     post
title:      【译】Redis数据类型和抽象化的介绍(全)
subtitle:   Redis数据类型
date:       2018-12-01
author:     WGrape
header-img: 
catalog: true
tags:
    - Redis
---

## 【译】Redis数据类型和抽象化的介绍(全)

> 原文 [《An introduction to Redis data types and abstractions》](https://redis.io/topics/data-types-intro)<br/>
> 译者：[WGrape](https://github.com/WGrape)

### 介绍

Redis不是普通的键值存储，它实际上是一个数据结构服务器，支持存储不同类型的数据。 也就是说，在传统的键值存储系统中，你只能使用把字符串的键与字符串的值相关联的存储方式，但在Redis中，存储的数据不仅限于简单的字符串，还可以是更复杂的数据结构。以下列出的是Redis支持的所有类型的数据结构，本教程将单独介绍它们：

- 二进制安全字符串(Binary-safe strings)。
- 列表(Lists) : 根据插入的元素顺序而排序的集合。其实就是链表(Linked Lists)。
- 集合(Sets) : 无序的不同的字符串元素的集合。
- 有序集合(Sorted Sets) : 类似于```集合(Sets)```，但是其中的每个字符串元素都会和一个浮点数值相关联，称为分数。通常根据每个字符串元素所关联的```score分数```大小给它们排序。因此，与```集合(Sets)```不同, ```有序集合(Sorted Sets)```可以检索一系列的元素(例如你可能需要：获取前10个元素，或者获取后10个元素)。
- 哈希表(Hashs)：由与```field```和```value```相关联而组成的映射表。```field```和```value```都是字符串。与 Ruby 或 Python 的哈希表类似。
- Bit数组(Bit arrays , 或者是简单的位图Bitmaps) : 使用特殊的命令，像操作一个bit数组一样处理字符串值，你可以设置和清除各个位，将所有为设置为1，找出第一个已设置或者未设置的位，以此类推。
- HyperLogLog( HLL ) ： 这是一种概率数据结构，用于估计集合的基数。不要害怕，它其实很简单，可以参见本教程的 HyperLogLog 部分。

掌握这些数据类型并且知道它们是如何工作的，以及使用命令行中的什么命令来解决给定问题，这些都是很重要的，所以本文档是学习Redis数据类型及其最常见模式的速成课程。

所有的示例，我们将使用```redis-cli```工具（一个简单方便的命令行工具）向对Redis服务器发出命令。

### Redis 键

Redis键是二进制安全的，这意味着你可以使用任何二进制序列作为键，从“foo”这样的字符串到JPEG这样的文件中的内容，它们都可以作为键，空字符串也是有效键。

关于键的其他规则：

-很长的钥匙不是一个好主意。 例如，1024字节的键不仅是内存方面的坏主意，而且因为在数据集中查找键可能需要几次昂贵的键比较。 即使当前的任务是匹配大值的存在，散列它（例如使用SHA1）也是一个更好的主意，特别是从内存和带宽的角度来看。
- 非常短的键往往不是一个好主意。 如果你可以改写“user：1000：followers”，那么将“u1000flw”写为关键点几乎没有意义。 后者更易读，与键对象本身和值对象使用的空间相比，增加的空间较小。 虽然短按键显然会消耗更少的内存，但你的工作就是找到合适的平衡点。
- 尝试坚持使用架构。 例如，“object-type：id”是一个好主意，如“user：1000”。 点或短划线通常用于多字词字段，如“comment：1234：reply.to”或“comment：1234：reply-to”。
- 键所允许的最大值是 512MB

### Redis 字符串

字符串是作为Redis键的最简单的类型。它是Memcached中唯一的数据类型，因此对于新手来说，在Redis中使用它也是非常自然的。

由于Redis键是字符串，当我们使用字符串类型作为值时，我们将字符串映射到另一个字符串。 字符串数据类型对许多用例很有用，例如缓存HTML片段或页面。

让我们使用redis-cli对字符串类型进行一些操作（所有示例都将在本教程中通过redis-cli执行）。

```
> set mykey somevalue
OK
> get mykey
"somevalue"
```

正如你所看到的，使用SET和GET命令是我们设置和检索字符串值的方式。 请注意，即使键与非字符串值相关联，SET也将替换已存在于键中的任何现有值。 所以SET执行一项任务。

值可以是各种字符串（包括二进制数据），例如，你可以将jpeg图像存储在值中。值不能大于512 MB。

SET命令有一些有趣的选项，它们作为附加参数提供。 例如，如果键已经存在，我可能会要求SET失败，或者相反，如果键已经存在，它只会成功：

```
> set mykey newval nx
(nil)
> set mykey newval xx
OK
```

即使字符串是Redis的基本值，也可以使用它们执行有趣的操作。例如，一个是原子增量：

```
> set counter 100
OK
> incr counter
(integer) 101
> incr counter
(integer) 102
> incrby counter 50
(integer) 152
```

INCR命令将字符串值解析为整数，将其递增1，最后将获取的值设置为新值。还有其他类似的命令，如INCRBY，DECR和DECRBY。在内部，它始终是相同的命令，以稍微不同的方式运作。 

INCR是原子的意味着什么？即使是针对相同键发布INCR的多个客户端也不会进入竞争状态。例如，客户端1读取“10”永远不会发生，客户端2同时读取“10”，两者都增加到11，并将新值设置为11.最终值将始终为12并且读取当所有其他客户端不同时执行命令时，执行增量设置操作。

有许多用于操作字符串的命令。例如，GETSET命令将键设置为新值，并将旧值作为结果返回。例如，如果你的系统在每次网站收到新访问者时使用INCR递增Redis键，则可以使用此命令。你可能希望每小时收集一次此信息，而不会丢失一个增量。你可以GETSET键，为其分配新值“0”并返回旧值。

在单个命令中设置或检索多个键的值的能力对于减少延迟也是有用的。因此，有MSET和MGET命令：

```
> mset a 10 b 20 c 30
OK
> mget a b c
1) "10"
2) "20"
3) "30"
```
使用MGET时，Redis返回值数组。 

### 更改和查询键的空间

有些命令没有在特定类型上定义，但是为了与键空间交互很有用，因此可以与任何类型的键一起使用。 

例如，EXISTS命令返回1或0以表示数据库中是否存在给定键，而DEL命令删除键和关联值，无论值是什么。

```
> set mykey hello
OK
> exists mykey
(integer) 1
> del mykey
(integer) 1
> exists mykey
(integer) 0
```

从示例中，你还可以看到DEL本身如何返回1或0，具体取决于键是否被删除（它是否存在）（没有具有该名称的键）。 

有许多与键空间相关的命令，但上面两个是与TYPE命令一起必不可少的命令，它返回存储在指定键中的值的类型：

```
> set mykey x
OK
> type mykey
string
> del mykey
(integer) 1
> type mykey
none
```

### Redis到期：生活时间有限的键

在继续使用更复杂的数据结构之前，我们需要讨论另一个无论值类型如何都能工作的特性，并称为Redis过期。 基本上，你可以为键设置超时，这是一个有限的生存时间。 当生存时间过去时，键会自动销毁，就像用户使用键调用DEL命令一样。

关于Redis的一些快速信息到期：

1. 它们可以使用秒或毫秒精度进行设置。 
2. 但是，到期时间分辨率始终为1毫秒。 
3. 有关过期的信息将被复制并保留在磁盘上，当Redis服务器保持停止时，这个时间实际上会消失（这意味着Redis会保存键过期的日期）。

设置过期是微不足道的：

```
> set key some-value
OK
> expire key 5
(integer) 1
> get key (immediately)
"some-value"
> get key (after some time)
(nil)
```

两个GET呼叫之间的键消失了，因为第二个呼叫被延迟超过5秒。 在上面的示例中，我们使用EXPIRE来设置expire（它也可以用来为已经有一个的键设置不同的expire，就像PERSIST可以用来删除过期并使键永久持久化）。 但是，我们也可以使用其他Redis命令创建过期键。 例如，使用SET选项：

```
> set key 100 ex 10
OK
> ttl key
(integer) 9
```

上面的示例设置一个字符串值为100的键，其过期为十秒。 稍后调用TTL命令以检查键的剩余生存时间。

要以毫秒为单位设置和检查过期，请检查PEXPIRE和PTTL命令以及SET选项的完整列表。

### Redis Lists

为了解释List数据类型，最好从一点理论开始，因为术语List经常被信息技术人员以不正当的方式使用。例如，“Python Lists”不是名称所暗示的（Linked Lists），而是Arrays（实际上相同的数据类型在Ruby中称为Array）。

从非常一般的角度来看，List只是一系列有序元素：10,20,1,2,3是一个列表。但是使用Array实现的List的属性与使用Linked List实现的List的属性非常不同。 

Redis列表通过链接列表实现。这意味着即使列表中有数百万个元素，也会在常量时间内在列表的头部或尾部添加新元素。使用LPUSH命令将新元素添加到具有十个元素的列表头部的速度与将一个元素添加到具有1000万个元素的列表头部相同。

有什么缺点？在使用Array（常量时间下标访问）实现的列表中，通过下标访问元素非常快，而在链接列表实现的列表中则不是那么快（其中操作需要与所访问元素的下标成比例的工作量）。 

Redis列表使用链表实现，因为对于数据库系统而言，能够以非常快的方式将元素添加到很长的列表中是至关重要的。正如你马上将看到的那样，Redis Lists可以在恒定时间内以恒定长度获取到。(Todo:不确定是不是这样翻译！)

当非常需要快速访问大量元素集合的中间位置时，可以使用不同的数据结构，称为有序集合(Sorted Sets)。有序集合将在本教程后面介绍。

### 使用 Redis Lists 的第一步

```LPUSH```命令将新元素添加到列表的左侧(头部)中，而```RPUSH```命令将新元素添加到列表的右侧(尾部)中。最后，```LRANGE```命令从列表中提取某个范围内的元素：

```
> rpush mylist A
(integer) 1
> rpush mylist B
(integer) 2
> lpush mylist first
(integer) 3
> lrange mylist 0 -1
1) "first"
2) "A"
3) "B"
```

请注意，```LRANGE```需要两个下标，即要返回范围内的第一个和最后一个元素。 两个下标都可以是负数，告诉Redis从结尾开始计数：所以-1是最后一个元素，-2是列表的倒数第二个元素，依此类推。

如你所见，```RPUSH```向列表右侧添加了元素，而最后的```LPUSH```向列表的左侧添加了的元素。

这两个命令都是可变参数命令，这意味着你可以在一次调用中将多个元素自由地```push```到列表中：

```
> rpush mylist 1 2 3 4 5 "foo bar"
(integer) 9
> lrange mylist 0 -1
1) "first"
2) "A"
3) "B"
4) "1"
5) "2"
6) "3"
7) "4"
8) "5"
9) "foo bar"
```

Redis Lists 中定义的一个重要操作是弹出元素的能力。弹出元素是从列表中检索元素并同时从列表中删除元素的操作。 你可以从左侧和右侧弹出元素，同样的，你也可以从左侧和右侧```Push```元素：

```
> rpush mylist a b c
(integer) 3
> rpop mylist
"c"
> rpop mylist
"b"
> rpop mylist
"a"
```

我们添加了三个元素并弹出了三个元素，因此在这个命令序列执行结束后，列表为空，并且没有更多元素可以弹出。 如果我们尝试弹出另一个元素，我们会得到这样的结果：

```
> rpop mylist
(nil)
```

Redis返回NULL值以表示列表中没有元素。

> 待续 ... ...
